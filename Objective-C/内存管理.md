# ARC
> Automatic Reference Countting 指内存管理使用引用采用自动计数的技术，在LLVM中设置ARC有效的时候，就无需（禁止）使用retain或者release代码了

使用限制：
- Xcode 版本4.2及以上的版本
- LLVM编译器3.0及以上的版本
- 编译器选项设置ARC有效

![](media/15310375066928.jpg)



## 内存管理的思考方式
- 自己生成的对象，自己持有
- 非自己生成的对象，自己也能持有
- 不再需要自己持有的对象时释放
- 非自己持有的对象不能释放



| 对象操作 | Object-C 方法 |
| --- | --- |
| 生成并持有对象 | alloc/new/copy/mutableCopy |
| 持有对象 | retain |
| 释放对象 | release |
| 废弃对象 | dealloc |

其中alloc等方法，符合驼峰命名的方式（CamelCase）的方式也是例如：
allocMyObject

非自己持有的对象不能释放
![](media/15310381930038.jpg)


```objc
	{
		//自己生成的对象自己持有
		NSObject *obj  = [[NSObject alloc] init];
		//不在需要时，自己释放
		[obj release];
	}
	
	{
		//取的非自己生成的对象
		id array = [NSArray array];
		//可以持有，不自己生成的对象
		[array retain];
		[array release];
	}
```

### autorelease 
> 如同c语言的自动变量来对待对象实例，当超出其作用范围时，对象实例的release方法被调用


```objc
{
		//ARC无效
		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
		id obj = [NSObject new];
		[obj autorelease];
		[pool drain];
	}
```

在RunLoop中每次循环会自动的生成和废弃NSAutoreleasePool对象

## 所有权修饰符
ARC 有效时，必须加上所有权修饰符。所有权一共有4种：

- __strong
- __weak
- __unsafe_unretained
- __autoreleasing

### __strong
> 对象类型的默认所有权修饰符，就是不添加修饰符默认会编译器会自动添加__strong修饰符

![](media/15310402598948.jpg)

 


